% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/monitor.R
\name{vetiver_compute_metrics}
\alias{vetiver_compute_metrics}
\alias{vetiver_pin_metrics}
\alias{vetiver_plot_metrics}
\title{Aggregate, store, and plot model metrics over time for monitoring}
\usage{
vetiver_compute_metrics(
  data,
  date_var,
  unit,
  truth,
  estimate,
  ...,
  metric_set = yardstick::metrics
)

vetiver_pin_metrics(
  df_metrics,
  date_var,
  board,
  metrics_pin_name,
  initiate = FALSE
)

vetiver_plot_metrics(
  df_metrics,
  date_var,
  .estimate = .estimate,
  .metric = .metric,
  n = n
)
}
\arguments{
\item{data}{A \code{data.frame} containing the \code{truth} and \code{estimate}
columns and any columns specified by \code{...}.}

\item{date_var}{The column in \code{data} containing dates or date-times for
monitoring, to be aggregated with \code{unit}}

\item{unit}{a character string specifying a time unit or a multiple of a unit
to be rounded to. Valid base units are \code{second}, \code{minute}, \code{hour}, \code{day},
\code{week}, \code{month}, \code{bimonth}, \code{quarter}, \code{season}, \code{halfyear} and
\code{year}. Arbitrary unique English abbreviations as in the \code{\link[lubridate:period]{period()}}
constructor are allowed. Rounding to multiples of units (except weeks) is
supported.}

\item{truth}{The column identifier for the true results (that
is \code{numeric} or \code{factor}). This should be an unquoted column name
although this argument is passed by expression and support
\link[rlang:nse-force]{quasiquotation} (you can unquote column
names).}

\item{estimate}{The column identifier for the predicted results
(that is also \code{numeric} or \code{factor}). As with \code{truth} this can be
specified different ways but the primary method is to use an
unquoted variable name.}

\item{...}{A set of unquoted column names or one or more
\code{dplyr} selector functions to choose which variables contain the
class probabilities. If \code{truth} is binary, only 1 column should be selected.
Otherwise, there should be as many columns as factor levels of \code{truth}.}

\item{metric_set}{A \code{\link[yardstick:metric_set]{yardstick::metric_set()}} function for computing metrics.
Defaults to \code{\link[yardstick:metrics]{yardstick::metrics()}}.}

\item{df_metrics}{A tidy dataframe of metrics over time, such as created by
\code{vetiver_compute_metrics()}.}

\item{board}{A pin board, created by \code{\link[pins:board_folder]{board_folder()}}, \code{\link[pins:board_rsconnect]{board_rsconnect()}},
\code{\link[pins:board_url]{board_url()}} or another \code{board_} function.}

\item{metrics_pin_name}{Pin name for where the \emph{metrics} are stored (as
opposed to where the model object is stored with \code{\link[=vetiver_pin_write]{vetiver_pin_write()}}).}

\item{initiate}{Are you starting a new set of monitoring metrics to
pin/store? Defaults to \code{FALSE}.}

\item{.estimate}{The variable in \code{df_metrics} containing the metric estimate.
Defaults to \code{.estimate}.}

\item{.metric}{The variable in \code{df_metrics} containing the metric type.
Defaults to \code{.metric}.}

\item{n}{The variable in \code{df_metrics} containing the number of observations
used for estimating the metric.}
}
\value{
Both \code{vetiver_compute_metrics()} and \code{vetiver_pin_metrics()} return
a dataframe of metrics. The \code{vetiver_plot_metrics()} function returns a
\code{ggplot2} object.
}
\description{
These three functions can be used for model monitoring (such as in a
monitoring dashboard):
\itemize{
\item \code{vetiver_compute_metrics()} computes metrics (such as accuracy for a
classification model or RMSE for a regression model) at a chosen time
aggregation \code{unit}
\item \code{vetiver_pin_metrics()} updates (or creates) a pin storing model metrics
over time
\item \code{vetiver_plot_metrics()} creates a plot of metrics over time
}
}
\details{
For arguments used more than once in your monitoring dashboard,
such as \code{date_var}, consider using
\href{https://bookdown.org/yihui/rmarkdown/parameterized-reports.html}{R Markdown parameters}
to reduce repetition and/or errors.
}
\examples{
library(dplyr)
library(parsnip)
data(Chicago, package = "modeldata")
Chicago <- Chicago \%>\% select(ridership, date, one_of(stations))
training_data <- Chicago \%>\% filter(date < "2008-12-31")
testing_data <- Chicago \%>\% filter(date > "2009-01-01", date < "2010-12-31")
monitoring <- Chicago \%>\% filter(date > "2011-01-01", date < "2012-12-31")
lm_fit <- linear_reg() \%>\% fit(ridership ~ ., data = training_data)

library(pins)
b <- board_temp()

## before starting monitoring, initiate the metrics and pin
## (for example, with the testing data):
original_metrics <-
    augment(lm_fit, new_data = testing_data) \%>\%
    vetiver_compute_metrics(date, "month", ridership, .pred) \%>\%
    vetiver_pin_metrics(date, b, "lm_fit_metrics", initiate = TRUE)

## to continue monitoring with new data, compute metrics and update pin:
new_metrics <-
    augment(lm_fit, new_data = monitoring) \%>\%
    vetiver_compute_metrics(date, "month", ridership, .pred) \%>\%
    vetiver_pin_metrics(date, b, "lm_fit_metrics")

library(ggplot2)
vetiver_plot_metrics(new_metrics, date) +
    scale_size(range = c(2, 4))

}
